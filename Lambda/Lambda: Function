Function is a part which has the executable code.

Function can be define as:-
  - A source code 
  - A Container image file
  
Function as image file:-
  - For this you have to provide the Amazon ECR url.
  - You can also override beow configuration for image. Entrypoint, Command, Working directory
  - When you deploy code as a container image to a Lambda function, the image undergoes an optimization process for running on Lambda. 
    This process can take a few seconds, during which the function is in PENDING state. When the optimization process completes, the function enters the ACTIVE state.
    If function not called for weeks then lambde reclain the Optomized version and Lambda goes in INACTIVE state. It must be called at least once to put it in ACTIVS stae.
  - You must ensure that the Role/User who create this lambda (not Execution Role) must have the permission 'GetRepositoryPolicy and SetRepositoryPolicy'

Enviorment Variable[EV]:-
  An environment variable is a pair of strings that are stored in a function's version-specific configuration.
  You can use environment variables to adjust your function's behavior without updating code. 
  - You define EV on the unpublished version of your function. When you publish a version, the EV are locked for that version  
  - Reserved environment variables: _HANDLER, AWS_REGION, _X_AMZN_TRACE_ID, AWS_EXECUTION_ENV  etc.
  - By default EV is encrypted at rest with AWS managed CMK.  You can use diffrent CMK also.
      For default CMK you do not need AWS KMS permission but for other CMK user/Execution role needs AWS KMS permission for that CMK.
  

Cocurrency:-
  In AWS lambda there is overall limit for number of paraller execution count for any aws account and that is 1000
  It means combining all lembda function the max possible run at a time is 1000.
  if more lambda execution are requested then it will be denied and a response with 'TooManyRequestException' error with code 549 will be received.
    - This limit is on the account across all the lambda not for each lambda.
    - You increase the account level reserve from 1000. but for this you have to raise the support ticket at aws.
    - if there is more invocation of lambda (all lambda in account inculding there version) then limit then it get throttle. 
   
  Reserved Cocurrency:-
    As you know there is a limit on overall account and so on all the lambada combined. 
    But lets say there is some funcvtions that you think are mission critical na dyou wants them to when needed.
    But you knw that there is a overall limit.
    To solve this we can reserve the cocurency for those function. This will actully keep some cocurucy reserved for mission critical lambda
    How:
      AWS > Lambda > 'you lambda' > in section Concurrency set the value of reserved cocurency.
      The rest of the cocurrency will be left for the rest of the lambda functions.    
    - Reserved Cocurrency applies to the function as a whole, including versions and aliases
    - Value of Reserved Cocurrency also limit max the number of lambda executed cocurrently. if there is more invocation of this lambda then reserved limit then it get throttle. 

  Provisioned Cocurency :-
    To handle the issue in Cold Start or Warm Up AWS provided the 'provisioned cocurency'
    By this you can keep number of cotainer of this lambda alive even when there is 0 traffic. the advantage is you not have to worry about cold start. 
    - This is chargable and more the provisioned capacity more the charges will be. 
    - There is maximum limit of overall capacity across any account and that is 1000
    - Provisioned amount will be deducted from reserved capacity.
    - Provisioned Cocurrency can be applied to the versions or aliases of the function
    - You can't allocate more provisioned concurrency than reserved concurrency for a function
    
    Auto Scalling of Provision Capacity:-
      Lambda also integrates with Application Auto Scaling. You can configure Application Auto Scaling to manage provisioned concurrency based on   
        - Schedule
        - Scalling Policy
    
    reserved VS provisioned:-
      reserved cocurrency will be reserved for designated lambda but containers will not be initiated. Free
      provisioned cocurrency will reserved for designated lambda along with containers initiated. Chargable
    
    Throttle:-
      The lambda get throttle if either:-
        - Reserved limit of specific lambda reached
        - account limit for all lambdas is reached.
    
----------------------

Version and Alias:-
  Version:-
    You can publish the diffrent version of Lambda. This is immutable copy of latest unpublished version.
    Once you publish the lambda it locks below item for created version
    - Function code and all associated dependencies.
    - The Lambda runtime that invokes the function.
    - Function settings, including the environment variables.
    - A unique Amazon Resource Name (ARN) to identify the specific version of the function

    ARN of Publised version function:-
      arn:aws:lambda:aws-region:acct-id:function:helloworld:42
    ARN of UnPublised version function:-
      arn:aws:lambda:aws-region:acct-id:function:helloworld
      arn:aws:lambda:aws-region:acct-id:function:helloworld:$LATEST
  
  Alias:-
    Alias is a pointer to the specific version of Lambda. You can update an alias to point to a new version of the function.
    At a time alias can point to any single version of lamda.
    You can access that version of fuction using alia too.
    like ARN:-
       arn:aws:lambda:aws-region:acct-id:function:helloworld:PROD
    Advatange of using Alias is that you can create new version of the Lambda and adjust the pointer of alias [PROD/DEV/APAC etc] to new version.
    and so wherver if you have used the alias ARN of this lambda, will have new version of the lambda to be executed.
    
    Weighted alias:-
      With weighted alias you can creat custom routing to delivercertain portion of traffic to certain version of Lambda.
      This is usful for beta testing. You can set like send 10% of traffic to version 10 and 90% to version 11 for alias :PROD 
    
------------------------------

Layer:-
  You can configure your Lambda function to pull in additional code and content in the form of layers. 
  A layer is a .zip file archive that contains libraries, a custom runtime, or other dependencies. 
  With layers, you can use libraries in your function without needing to include them in your deployment package and keep development package small.
  Layers are versioned and you can use ARN in the Lambda to point to specific version. 
  
------------------------------

Lambda and Memory:-
  To configure the memory for your function, set a value between 128 MB and 10,240 MB in 1-MB increments
-------------------------------

Error Handling:-
  In lambda there could be two kind of error.
  1. Invocation Error
      Invocation errors occur when the invocation request is rejected before your function receives it.
      Causes:-
         - Requset too large
         - Caller User/Role do not has permission for 'Invoke'
         - Cocurrency limit reach
      This produce result with 4XX or 5XX code.
  2. Function Error:-
      Once Invocation of function is passe then, Function Error occure inside the function's code. Runtime error.
      This produce result with 200 success. 
      Lambda indicates this by including a header named X-Amz-Function-Error, and a JSON-formatted response with the error message and other details
      
  Error handling for Asynchronus Invoke:-
    Intially lambda will rery the event and keep retrying with increasinf interval. but if it fail yet them
    You can use dead letter queue for handling the discarded event.
      
----------------------------------

Lambda Execution Lifecycle:-
  THere is 3 phases of lambda execution.
  1. Init:-
      In this phase the container get initilize. 
      The Init phase happens either during the first invocation, or in advance of function invocations if you have enabled provisioned concurrency.
      In this phase lambda 
        > configured resources, 
        > downloads the code for the function and all layers, 
        > initializes any extensions, 
        > initializes the runtime
  2. Invoke:-
      Here the function code get executed. once done with the handled. it become ready for another execution.
  3. Shutdown:-
      This phase is triggered if the Lambda function does not receive any invocations for a period of time. 
      In the Shutdown phase, Lambda terminates the runtime, alerts the extensions to let them stop cleanly, and then removes the environment
      
  Between Init and Shutdown, there could be multiple trigger of Invoke for multiple invocation.
  After the function and all extensions have completed, Lambda maintains the execution environment for some time in anticipation of another function invocation. 
  In effect, Lambda freezes the execution environment. When the function is invoked again, Lambda thaws the environment for reuse
  
  Timeout Setting:-
    This setting limit the maximum time the handler function can take for execution. if it goes above this limit then function get terminated. 
     
  Object outside Handler:-
    Objects declared outside of the function's handler method remain initialized, providing additional optimization when the function is invoked again.
    EG: you can create the DB connection outside the Handler and reuse this connection for all invocation handled by this Execution environment.
    
  Temp Disk Space:-
    Each execution environment provides 512 MB of disk space in the /tmp directory. 
    The directory content remains when the execution environment is frozen, providing a transient cache that can be used for multiple invocations.
  
  Callbacks in Handler:-
    Using callack in handler is very risky. LAmbda return immediatly and do not wait for callback to be executed. in this if your Execution Enviorment got vanished
    then your callback goes in vain or not executed at all.
  
    
    
    
    
    
    



