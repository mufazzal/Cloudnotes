Function is a part which has the executable code.

Function can be define as:-
  - A source code 
  - A Container image file
  
Function as image file:-
  - For this you have to provide the Amazon ECR url.
  - You can also override beow configuration for image. Entrypoint, Command, Working directory
  - When you deploy code as a container image to a Lambda function, the image undergoes an optimization process for running on Lambda. 
    This process can take a few seconds, during which the function is in PENDING state. When the optimization process completes, the function enters the ACTIVE state.
    If function not called for weeks then lambde reclain the Optomized version and Lambda goes in INACTIVE state. It must be called at least once to put it in ACTIVS stae.
  - You must ensure that the Role/User who create this lambda (not Execution Role) must have the permission 'GetRepositoryPolicy and SetRepositoryPolicy'

Enviorment Variable[EV]:-
  An environment variable is a pair of strings that are stored in a function's version-specific configuration.
  You can use environment variables to adjust your function's behavior without updating code. 
  - You define EV on the unpublished version of your function. When you publish a version, the EV are locked for that version  
  - Reserved environment variables: _HANDLER, AWS_REGION, _X_AMZN_TRACE_ID, AWS_EXECUTION_ENV  etc.
  - By default EV is encrypted at rest with AWS managed CMK.  You can use diffrent CMK also.
      For default CMK you do not need AWS KMS permission but for other CMK user/Execution role needs AWS KMS permission for that CMK.
  

Cocurrency:-
  In AWS lambda there is overall limit for number of paraller execution count for any aws account and that is 1000
  It means combining all lembda function the max possible run at a time is 1000.
  if more lambda execution are requested then it will be denied and a response with 'TooManyRequestException' error with code 549 will be received.
    - This limit is on the account across all the lambda not for each lambda.
    - You increase the account level reserve from 1000. but for this you have to raise the support ticket at aws.
   
  Reserved Cocurrency:-
    As you know there is a limit on overall account and so on all the lambada combined. 
    But lets say there is some funcvtions that you think are mission critical na dyou wants them to when needed.
    But you knw that there is a overall limit.
    To solve this we can reserve the cocurency for those function. This will actully keep some cocurucy reserved for mission critical lambda
    How:
      AWS > Lambda > 'you lambda' > in section Concurrency set the value of reserved cocurency.
      The rest of the cocurrency will be left for the rest of the lambda functions.    
    - Reserved Cocurrency applies to the function as a whole, including versions and aliases

  Provisioned Cocurency :-
    To handle the issue in Cold Start or Warm Up AWS provided the 'provisioned cocurency'
    By this you can keep number of cotainer of this lambda alive even when there is 0 traffic. the advantage is you not have to worry about cold start. 
    - This is chargable and more the provisioned capacity more the charges will be. 
    - There is maximum limit of overall capacity across any account and that is 1000
    - Provisioned amount will be deducted from reserved capacity.
    - Provisioned Cocurrency can be applied to the versions or aliases of the function
    - You can't allocate more provisioned concurrency than reserved concurrency for a function
    
    Auto Scalling of Provision Capacity:-
      Lambda also integrates with Application Auto Scaling. You can configure Application Auto Scaling to manage provisioned concurrency based on   
        - Schedule
        - Scalling Policy
    
    reserved VS provisioned:-
      reserved cocurrency will be reserved for designated lambda but containers will not be initiated. Free
      provisioned cocurrency will reserved for designated lambda along with containers initiated. Chargable

----------------------

Version and Alias:-
  Version:-
    You can publish the diffrent version of Lambda. This is immutable copy of latest unpublished version.
    Once you publish the lambda it locks below item for created version
    - Function code and all associated dependencies.
    - The Lambda runtime that invokes the function.
    - Function settings, including the environment variables.
    - A unique Amazon Resource Name (ARN) to identify the specific version of the function

    ARN of Publised version function:-
      arn:aws:lambda:aws-region:acct-id:function:helloworld:42
    ARN of UnPublised version function:-
      arn:aws:lambda:aws-region:acct-id:function:helloworld
      arn:aws:lambda:aws-region:acct-id:function:helloworld:$LATEST
  
  Alias:-
    Alias is a pointer to the specific version of Lambda. You can update an alias to point to a new version of the function.
    At a time alias can point to any single version of lamda.
    You can access that version of fuction using alia too.
    like ARN:-
       arn:aws:lambda:aws-region:acct-id:function:helloworld:PROD
    Advatange of using Alias is that you can create new version of the Lambda and adjust the pointer of alias [PROD/DEV/APAC etc] to new version.
    and so wherver if you have used the alias ARN of this lambda, will have new version of the lambda to be executed.
    
    Weighted alias:-
      With weighted alias you can creat custom routing to delivercertain portion of traffic to certain version of Lambda.
      Thi is usful for beta testing.
    
------------------------------

Layer:-
  You can configure your Lambda function to pull in additional code and content in the form of layers. 
  A layer is a .zip file archive that contains libraries, a custom runtime, or other dependencies. 
  With layers, you can use libraries in your function without needing to include them in your deployment package and keep development package small.
  Layers are versioned and you can use ARN in the Lambda to point to specific version. 
  
------------------------------

Lambda and Memory:-
  To configure the memory for your function, set a value between 128 MB and 10,240 MB in 1-MB increments
-------------------------------

Error Handling:-
  In lambda there could be two kind of error.
  1. Invocation Error
      Invocation errors occur when the invocation request is rejected before your function receives it.
      Causes:-
         - Requset too large
         - Caller User/Role do not has permission for 'Invoke'
         - Cocurrency limit reach
      This produce result with 4XX or 5XX code.
  2. Function Error:-
      Once Invocation of function is passe then, Function Error occure inside the function's code. Runtime error.
      This produce result with 200 success. 
      Lambda indicates this by including a header named X-Amz-Function-Error, and a JSON-formatted response with the error message and other details
      
  Error handling for Asynchronus Invoke:-
    Intially lambda will rery the event and keep retrying with increasinf interval. but if it fail yet them
    You can use dead letter queue for handling the discarded event.
      
    
  


  
    
    
    
    
    
    



