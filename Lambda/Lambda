Lambda is the smallest unit of code that can run as serverless on AWS system.

Lambda and IAM Role:-
  You have to assign a Role to ypur lembda function. and tahe role must have a permission 'AWSLembdaExecute'.
  Along with this yous should also assign the permission if you wants to access/change/operate any other AWS service
  So create the Role you wants first
  
Creating the Lembda:-
  1.  Compute > Lembda > Create Lembda
  2.  input the name and desc
  3.  Choose Role you created earlier
  4.  Chosse runtime like Node, Java etc.
  5.  either write code or upload the ZIP
    5.1 if file is ZIP then you must specify 'Handler' as <fileName>.<functionName>, which will be placed at root of ziped folder
  6 Also set the env variable if required {eg. if runtime is Node then you can use process.env.<envVarName> in the code and set its value in AWS console}
  Now you are done with the code But when this little pice of code will ran ?
  Next! Lets set the trigger for this Lambda
  7. AWS COnsole > Lambda > Functions > select your lambda function > configuration > Add Trigger
  8 Now here the configuration of trigger is done. This is very abstract topic and you can set up diffrent AWS service to trigger this 
    function for you
    E.G : you can Select S3, then select the bucket in it and set the event like upload, delete, edit file to trigger this event
  Done
  
  Plz note that reserved concurrency means that we keep
  Some cocurency for our function. Its not like that
  100s of lambda kept in warm state all the time.
   For this feature u have to use provisioned cocurency


 Setting up envirment vasrible:-
  You can use the env variable in the code and supply its value via aws console.
  EG: in node runtime-
    ...
    if(process.env.isprod === tru)
      ...
    now set the value of 'isprod' in aws console simply.
  
 ---------
Q:  How many lambda can be call cocurrently
A:  1000

Q   Max time a lambda can take for execution?
A.  5 minutes. after that it fail.
-----------------------------


Cocurrency:-
  In AWS lambda there is overall limit for number of paraller execution count for any aws account and that is 1000
  It means combining all lembda function the max possible run at a time is 1000.
  if more lambda execution are requested then it will be denied and a response with 'TooManyRequestException' error with code 549 will be received.
  VIMP : this limit is on the account across all the lambda not for each lambda.
  
  Reserved Cocurrency:-
    As you know there is a limit on overall account and so on all the lambada combined. 
    But lets say there is some funcvtions that you think are mission critical na dyou wants them to when needed.
    But you knw that there is a overall limit.
    To solve this we can reserve the cocurency for those function. This will actully keep some cocurucy reserved for mission critical lambda
    How:
      AWS > Lambda > 'you lambda' > in section Concurrency set the value of reserved cocurency.
      The rest of the cocurrency will be left for the rest of the lambda functions.    
    
   Q: Can you increase the account level reserve from 1000?
   A: Yes, but for this you have to raise the support ticket at aws.
    
    
---------


Lambda and VPC:
  By default lambda has no relation with any VPC(imcluding default VPC).
  Lambda in itself is a small piece of code that that execute on demand. in itself it is not a node like EC2 or RDS.
  Lambda do not lie in any VPC. and Lambda cannot have any Public or Private IP address attached to himself.
  BUT
  what if you nmeed to communicate with any node lie in VPC via lambda.
  EG: you wants to read the data from RDS which lie in a subnet of VPC, or you need to run a api hosted on EC2 lieing in VPC

  There is two possible scenarion
  SC1. The node (EC2, RDS etc) of VPC you wants to communicate lies in Public Subnet
        - In this case you do not have to do anything. becoz if node is in public subnet then it accessible via internrt and 
          you can simply communicate with then with public IP of those nodes.

   SC2. The node (EC2, RDS etc) of VPC you wants to communicate lies in private Subnet
        - This is tricky. If node is in private subnet then lambda also has to execute in VPC.
        
   Again two possible solution     
   we can host the Lambda in public or private sunbnet     
        
  sol1. Placing the Lambda in Public Subnet:-
          You can place it in public subnet but in that case lambda will not be able to access the public internet.
          Why
          Because even though the Lambda function is running inside a public subnet of a VPC, 
          But the Lambda functions do not, and cannot, have public IP addresses. 
          You cannot send traffic to the internet, via the VPC's Internet Gateway, 
          unless you have a IP(private). You would need to route through a NAT Getway.
          Lambda in public subnet can only access the nodes lieing in VPC not the internet. so its vert limiting.
          
   sol2: Placing the Lambda in Private Subnet without NAT getway:-           
          This is again of no use becoz private subnet without NAT getway cannot access the internet.
          
   sol3: Placing the Lambda in Private Subnet with NAT getway:-         
          This is perfect. here you can access all the nodes in VPA as well as the internet in the lambda function.
          
   How could i implement sol3?
   You will need
    - For NAT getway to exist you must fiest need at leat one public subnet.
    - A Private subnet with NAT getway attached to it
    - Security Group: This security group is wraped arroud the lambda so it should have proper inbound and outbound rule.
                        Generally lambda dont need any inbound rule as it is not like any server or DB which has an IP address.
                        and outbound should open to all internet.
                        So default VPC group is enough if you do not wants to restrict anything.
    - Execution Role: You know that lambda has a role. If you wants to put a lambda in VPC 
                        then the lambda should have the policy 'AWSLambdaVPCAccessExecutionRole' attached to it. 
    
    
    Steps:-
      1. AWS > LAmbda > you lambda function > go to VPC section > Edit
      2. set VPC connection to 'custom'
      3. Choose VPC
      4. Choose private subnet lying in that VPc. (choose at least two for high avilability)
      5. Select Security group ????????????
      6. Create a Role for the Lambda which has following polocy attached
          'AWSLambdaVPCAccessExecutionRole'
          TIP: You can create and assign it simply by using the template at
                6.1 AWS > LAmbda > you lambda function > Permission > Execution role > Edit
                6.2 ????????????????????
      7. Done.
      
      Now you cann access internet as well as all the private node lying in VPC.
      
      What happen in backgroud:-
        The step above are fairely simple but inside the aws it make lot of changes.
        When Lambda attach to any VPC, the AWS system actully use 'Elastic Network Interface' to create a network aroud the lambda 
        that connect the VPC. 
        To create this network tha lambda must need the permission 'AWSLambdaVPCAccessExecutionRole'
        Also once wrapped via ENI, the lambda also behave like a Node in network, simillar to EC2 or RDS.
        So any node the AWS network must have a security group that can tell what destination are safe for inbound and outbound communication
        
        
---------------

Lambda's IAM Role/Permissions at local development at you PC:-
  The lambda get it role when it is deployed over AWS. But in time of local development at you PC he can not have any role.
  For at a time of development if you wants to access the previlged resource then you have to onfigure the AWS user locally.
  
  How? See #AWSSDK_AUTH_BY_KEY_ID in 'AWS JS SDK.txt'
  The cofigured user locally must have all the permission that you will late give to the Lambda Role at deployed stage..
  
      
-----------------
  
Lambda and asynchronus operation:-
  As we know that the lambda run in a epameral container. It accept some input perameter and produce the response.
  This work fine if all the operation is synchronus but if some code in the lambda function is asynch then it has to 
  handle properly.
  
  The lambda should be capable to perform those asynch operation and then process the output of that asynch operation
  and then finally producce the response.
  
  Scenario 1: If you do not need anu asynch operation. like sum of two number.
    handler = (event) => {
      return event.a + event.b
    }
    This is simplest and most useless example. you hardly need it practically
    
  Scenario 1: involving any asynch operation
    There is diffrent way to handle this. we will see all of them and their advatages.

    1. With use of Callback:-
      IF your enviormrnt is < Nodejs8.x then you haver to use this. For greater version use asynch/await.
        
        exports.handler =  function(event, context, callback) {
              docClient.scan(paramsScan, function(err, data) {
                if(err) { var response = { statusCode: 500, body: JSON.stringify(err)};
                } else  { response = { statusCode: 200, body: JSON.stringify(data) }; }
                console.log(response)
                callback(null, response)
              });
              return <THE Output>
         });
      This approch is very legacy and you should not use. Though you have to if you are usin nodejs lesser then 8.x.
      The final produced result are sent into the callback methode.

    2. With asynch/await and promise:-
        This is the best approch and easiest one.
        
                exports.getUsers = async (event, context) => {
                      var paramsScan = { TableName: "UserOrder", }
                      const response = await docClient.scan(paramsScan).
                                  promise().
                                  then(function(err, data) {
                                    if(err) { var res = { statusCode: 500, body: JSON.stringify(err) };
                                    } else  { res = { statusCode: 200, body: JSON.stringify(data) };}
                                    return res;
                                  });
                      return response;
                 });
         With use of asynch/await the code wait for the await statement to produce the result of asynchronus operation
         once produce then the code move ahead.
         Then you can use the result of asynchronus operation for producing the final response.
         

  Asynchronus operation without any callback or asynch/await:-
      If your code has any asynchronuss operation but you do not use 'asynch/await' or callback then the result of this 
      asynchronuss operation will lost in vain.
      EG:-
            exports.getUsers = async (event, context) => {
                var paramsScan = { TableName: "UserOrder", }
                const response = docClient.scan(paramsScan, function(err, data) {
                              if(err) { var res = { statusCode: 500, body: JSON.stringify(err) };
                              } else  { res = { statusCode: 200, body: JSON.stringify(data) };}
                              console.log(res)	.....LNCO1
                              return res;
                            }).
                return response;		
             });
      --  The response return at here is not tha result scan query. it will be some random object.
          The lambda will return immediatly after initiating the scan. it wont wait fro the result to come. 
          So even though the result will come later the final output response would have already being sent.
          The 'LNCO1' will do pringt the result of scan query in console but this in not goes as final output return of lambda.

        So the best pattern is to use lambda with NodeJs10.X with 'asynch/await'

------------

Layer:-
  In the development of lambda the biggest challange is code size, and if code has lof of dependencies then the library code size got 
  bigger and bigger 
  for EG if you are using the NodeJs env, then it may be possibe the node_modules folder got too large and handler function is tiny in comparision.
  
  Now you know that we make changes only in handler function mot in libs. 
  so in every deployment why we should even deploy all the libe (node_modules in case of nodejs)
  Also if code size is large thjen you can not edit the code in aws console directly. 
  
  To solve this problem comes the concept of layer.
  
  Layer is the collection of set library that lambdas can use in the code. so you do not have to upload the whole lib+code
  in lambda instead you just upload the handler function and some necessary file if needed.
  This layed can be used with many lambda so it giv great reusability.
  
  AWS system take care that when code ask for any lib, it will firt check in lambda and then check in attached layesr to that lambda.
  
  
  How to create layer for nodejs libs:-
    say we wants to write a code for many lambda that use the 'aws-sdk', 'moment' and 'axious' node modules.
    so we will create a layer which will contain this three libs.
    The one most imp thing you must remember that the folder structure of the layer id proper. 
    fore node you have to place all the node_modules in the 'nodejs' folder 
    
    Creating Lob:->
    
      1. So simply create a directory 'commonlibs' and create the 'nodejs' folder in it and install all dependency here
          mufcommonlibs
            |---nodejs
                  |-----package.json
                  |-----node_modules
                            |--------aws-sdk
                            |--------moment
                            |--------axious

      2. Now zip the contyent of 'mufcommonlibs' (not folder mufcommonlibs) folder and create 'mufcommonlibs.zip'
      3. go to AWS console > Lambda > layers > Create
      4. type name, description, choose env as node
      5. upload the zip
      Done
    
    Attaching lib ->
      1. go to the lambda function on which you wants to attach the lib
      2. click on layer and then on Add Layer
      3. paste the ARN of created layer above.
      Done
      
    ** Accession the lib via layer is same as we do in normal scenarion   var awsSdk = require('aws-sdk')  
    
    
    Challande with LAyer:-
      With layer you have great liberty to not to deploy the libs with handler code. in aws enviormrnt the lambda get the refrence of lib
      from layers but what about local development
      if we do not have node_module folder in local the we cannot test the function locally.
      
      solutiin is that at the time of uploadint the handler function on lambda you do not zip the entire node_module folder
      or do not zip the the specific node modules that are available in the layer 
      
      ** you can also have combination of both, some node modules imported from layer and some are placed with handler function itself.

------------

provisioned cocurency :-
  You may have read the issue in Cold Start or Warm Up in serverless.txt.
  To solve this issue the AWS provided the 'provisioned cocurency'
  By this you can keep number of cotainer of this lambda alive even when there is 0 traffic. the advantage is you not have to 
  worry about cold start. 
  But this is chargable and more the provisioned capacity more the charges will be. 
  Remebber ther is maximum limit of overall capacity across any account and that is 1000
  you cannot have more lambda instances of any kind running more then 1000.
  So provisioned amount will be deducted from reserved capacity.
  
  reserved VS provisioned:-
    reserved cocurrency will be reserved for designated lambda but containers will not be initiated. Free
    provisioned cocurrency will reserved for designated lambda along with containers initiated. Chargable
  
Pricing :-

scaling:-


-----

lambda Edge :-

???????

--------------------

LAmbda and SetTimeout():-
  You can not keep lambda running forever. 
  Lambda functions life time is limited with 300 seconds, after 300 seconds, your function dies. 


-----------------------

LAmbda and Pricing:-
  You will be charge on two factor
    1. No of lambda: First 1 million is free and thereafter you will be charged 0.025 per 1 million request.
    2. Time taken by lambda for execution
    3. Memory allocated.
     

-----------

LAmbda Integration with other services:-
  Many of the AWS services can trigger the LAmbda on certain event.
    Like S3 on object copy/put, SNS or SQS on message, ClodWatc, API Gateway, Autoscalling Group etc.
  But some are not at all integrated with Lambda 
    EG: EC2, RDS. there is no way to trigger an lambda when an EC2 turn shut or stop, RDS goes oerloaded.
      ** Though you can set a Clogwatch event for those scenario and trigger the lambda by CW.
    
    
    




